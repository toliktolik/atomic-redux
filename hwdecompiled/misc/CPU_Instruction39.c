/*
 * Function: CPU_Instruction39
 * Address: 004c92f0
 * Category: misc
 * Generated by Ghidra Bulk Exporter
 */

#include "../heavy_weapon_deluxe.h"


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __fastcall CPU_Instruction39(uint param_1,byte *param_2,uint param_3,int param_4,uint param_5)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  uint extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  uint extraout_ECX_02;
  undefined4 extraout_ECX_03;
  undefined4 extraout_ECX_04;
  undefined4 extraout_ECX_05;
  undefined4 extraout_ECX_06;
  undefined4 extraout_ECX_07;
  undefined4 extraout_ECX_08;
  undefined4 extraout_ECX_09;
  uint extraout_ECX_10;
  uint extraout_ECX_11;
  undefined4 extraout_ECX_12;
  undefined4 extraout_ECX_13;
  undefined4 extraout_ECX_14;
  undefined4 extraout_ECX_15;
  byte *extraout_EDX;
  byte *extraout_EDX_00;
  byte *extraout_EDX_01;
  byte *extraout_EDX_02;
  byte *extraout_EDX_03;
  byte *extraout_EDX_04;
  byte *extraout_EDX_05;
  byte *extraout_EDX_06;
  byte *extraout_EDX_07;
  byte *extraout_EDX_08;
  byte *extraout_EDX_09;
  byte *extraout_EDX_10;
  byte *extraout_EDX_11;
  byte *extraout_EDX_12;
  byte *extraout_EDX_13;
  byte *extraout_EDX_14;
  byte *extraout_EDX_15;
  byte *extraout_EDX_16;
  byte *extraout_EDX_17;
  float local_24;
  float local_20;
  float local_1c;
  float local_18;
  float local_14;
  float local_10;
  float local_c;
  float local_8;
  
  iVar3 = param_4;
  uVar2 = param_3;
  uVar1 = *(uint *)(param_3 + 0x68);
  if ((uVar1 & 1) == 0) {
    CPU_Instruction20(param_1,param_2,param_3,"Missing IHDR before sBIT");
    param_1 = extraout_ECX;
    param_2 = extraout_EDX;
  }
  else {
    if ((uVar1 & 4) != 0) {
      CPU_Instruction21(param_1,param_2,param_3,"Invalid cHRM after IDAT");
      CPU_Instruction33(extraout_ECX_01,extraout_EDX_01,uVar2,param_5);
      return;
    }
    if ((uVar1 & 2) == 0) {
      if (((param_4 != 0) && ((*(uint *)(param_4 + 8) & 4) != 0)) &&
         ((*(uint *)(param_4 + 8) & 0x800) == 0)) {
        CPU_Instruction21(param_1,param_2,param_3,"Duplicate cHRM chunk");
        CPU_Instruction33(param_5,extraout_EDX_03,uVar2,param_5);
        return;
      }
    }
    else {
      CPU_Instruction21(param_1,param_2,param_3,"Missing PLTE before cHRM");
      param_1 = extraout_ECX_02;
      param_2 = extraout_EDX_02;
    }
  }
  uVar1 = param_5;
  if (param_5 != 0x20) {
    CPU_Instruction21(param_1,param_2,uVar2,"Incorrect cHRM chunk length");
    CPU_Instruction33(extraout_ECX_00,extraout_EDX_00,uVar2,uVar1);
    return;
  }
  CPU_Instruction26(param_1,(byte *)&param_3,uVar2,(byte *)&param_3,4);
  iVar4 = CPU_Instruction24((undefined1 *)&param_3);
  if (iVar4 == -1) {
    local_24 = 0.312713;
  }
  else {
    local_24 = (float)iVar4;
    if (iVar4 < 0) {
      local_24 = local_24 + _DAT_00532f34;
    }
    local_24 = local_24 * _DAT_005399d8;
  }
  CPU_Instruction26(&param_3,extraout_EDX_04,uVar2,(byte *)&param_3,4);
  iVar4 = CPU_Instruction24((undefined1 *)&param_3);
  if (iVar4 == -1) {
    local_20 = 0.329016;
  }
  else {
    local_20 = (float)iVar4;
    if (iVar4 < 0) {
      local_20 = local_20 + _DAT_00532f34;
    }
    local_20 = local_20 * _DAT_005399d8;
  }
  if (((local_24 < _DAT_00532f30 != (NAN(local_24) || NAN(_DAT_00532f30))) ||
      ((float)_DAT_0052cd40 < local_24)) ||
     ((local_20 < _DAT_00532f30 != (NAN(local_20) || NAN(_DAT_00532f30)) ||
      (((float)_DAT_0052cd40 < local_20 || ((float)_DAT_0052a0f0 < local_20 + local_24)))))) {
    CPU_Instruction21(extraout_ECX_03,extraout_EDX_05,uVar2,"Invalid cHRM white point");
    CPU_Instruction33(extraout_ECX_15,extraout_EDX_17,uVar2,0x18);
  }
  else {
    CPU_Instruction26(extraout_ECX_03,extraout_EDX_05,uVar2,(byte *)&param_3,4);
    iVar4 = CPU_Instruction24((undefined1 *)&param_3);
    if (iVar4 == -1) {
      local_1c = 0.64;
    }
    else {
      local_1c = (float)iVar4;
      if (iVar4 < 0) {
        local_1c = local_1c + _DAT_00532f34;
      }
      local_1c = local_1c * _DAT_005399d8;
    }
    CPU_Instruction26(extraout_ECX_04,(byte *)&param_3,uVar2,(byte *)&param_3,4);
    iVar4 = CPU_Instruction24((undefined1 *)&param_3);
    if (iVar4 == -1) {
      local_18 = 0.33;
    }
    else {
      local_18 = (float)iVar4;
      if (iVar4 < 0) {
        local_18 = local_18 + _DAT_00532f34;
      }
      local_18 = local_18 * _DAT_005399d8;
    }
    if ((((local_1c < _DAT_00532f30 != (NAN(local_1c) || NAN(_DAT_00532f30))) ||
         ((float)_DAT_0052cd40 < local_1c)) ||
        (local_18 < _DAT_00532f30 != (NAN(local_18) || NAN(_DAT_00532f30)))) ||
       (((float)_DAT_0052cd40 < local_18 || ((float)_DAT_0052a0f0 < local_18 + local_1c)))) {
      CPU_Instruction21(extraout_ECX_05,extraout_EDX_06,uVar2,"Invalid cHRM red point");
      CPU_Instruction33(extraout_ECX_14,extraout_EDX_16,uVar2,0x10);
      return;
    }
    CPU_Instruction26(&param_3,extraout_EDX_06,uVar2,(byte *)&param_3,4);
    iVar4 = CPU_Instruction24((undefined1 *)&param_3);
    if (iVar4 == -1) {
      local_14 = 0.3;
    }
    else {
      local_14 = (float)iVar4;
      if (iVar4 < 0) {
        local_14 = local_14 + _DAT_00532f34;
      }
      local_14 = local_14 * _DAT_005399d8;
    }
    CPU_Instruction26(extraout_ECX_06,extraout_EDX_07,uVar2,(byte *)&param_3,4);
    iVar4 = CPU_Instruction24((undefined1 *)&param_3);
    if (iVar4 == -1) {
      local_10 = 0.6;
    }
    else {
      local_10 = (float)iVar4;
      if (iVar4 < 0) {
        local_10 = local_10 + _DAT_00532f34;
      }
      local_10 = local_10 * _DAT_005399d8;
    }
    if (((local_14 < _DAT_00532f30 != (NAN(local_14) || NAN(_DAT_00532f30))) ||
        ((float)_DAT_0052cd40 < local_14)) ||
       ((local_10 < _DAT_00532f30 != (NAN(local_10) || NAN(_DAT_00532f30)) ||
        (((float)_DAT_0052cd40 < local_10 || ((float)_DAT_0052a0f0 < local_10 + local_14)))))) {
      CPU_Instruction21(extraout_ECX_07,extraout_EDX_08,uVar2,"Invalid cHRM green point");
      CPU_Instruction33(extraout_ECX_13,extraout_EDX_15,uVar2,8);
      return;
    }
    CPU_Instruction26(extraout_ECX_07,(byte *)&param_3,uVar2,(byte *)&param_3,4);
    iVar4 = CPU_Instruction24((undefined1 *)&param_3);
    if (iVar4 == -1) {
      local_c = 0.15;
    }
    else {
      local_c = (float)iVar4;
      if (iVar4 < 0) {
        local_c = local_c + _DAT_00532f34;
      }
      local_c = local_c * _DAT_005399d8;
    }
    CPU_Instruction26(&param_3,extraout_EDX_09,uVar2,(byte *)&param_3,4);
    iVar4 = CPU_Instruction24((undefined1 *)&param_3);
    if (iVar4 == -1) {
      local_8 = 0.06;
    }
    else {
      local_8 = (float)iVar4;
      if (iVar4 < 0) {
        local_8 = local_8 + _DAT_00532f34;
      }
      local_8 = local_8 * _DAT_005399d8;
    }
    if ((((local_c < _DAT_00532f30 != (NAN(local_c) || NAN(_DAT_00532f30))) ||
         (_DAT_00539c2c < local_c)) ||
        (local_8 < _DAT_00532f30 != (NAN(local_8) || NAN(_DAT_00532f30)))) ||
       ((_DAT_00539c2c < local_8 || (_DAT_00539c28 < local_8 + local_c)))) {
      CPU_Instruction21(extraout_ECX_08,extraout_EDX_10,uVar2,"Invalid cHRM blue point");
      CPU_Instruction33(extraout_ECX_12,extraout_EDX_14,uVar2,0);
      return;
    }
    iVar4 = CPU_Instruction33(extraout_ECX_08,extraout_EDX_10,uVar2,0);
    if (iVar4 == 0) {
      if ((*(uint *)(iVar3 + 8) & 0x800) == 0) {
        PNG_SetChromaticity(uVar2,iVar3,(double)local_24,(double)local_20,(double)local_1c,
                            (double)local_18,(double)local_14,(double)local_10,(double)local_c,
                            (double)local_8);
        return;
      }
      if (((((float)_DAT_0052d860 < ABS(local_24 - _DAT_00539c24)) ||
           ((float)_DAT_0052d860 < ABS(local_20 - _DAT_00539c20))) ||
          (((float)_DAT_0052d860 < ABS(local_1c - _DAT_00539c1c) ||
           ((((float)_DAT_0052d860 < ABS(local_18 - _DAT_00539c18) ||
             ((float)_DAT_0052d860 < ABS(local_14 - _DAT_00539c14))) ||
            ((float)_DAT_0052d860 < ABS(local_10 - _DAT_00539c10))))))) ||
         (((float)_DAT_0052d860 < ABS(local_c - _DAT_00539c0c) ||
          ((float)_DAT_0052d860 < ABS(local_8 - _DAT_00539c08))))) {
        CPU_Instruction21(extraout_ECX_09,extraout_EDX_11,uVar2,
                          "Ignoring incorrect cHRM value when sRGB is also present");
        String_ReallocateBuffer(extraout_ECX_10,extraout_EDX_12);
        String_ReallocateBuffer(extraout_ECX_11,extraout_EDX_13);
        return;
      }
    }
  }
  return;
}


