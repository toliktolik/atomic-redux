/*
 * Function: CPU_Instruction31
 * Address: 004c8770
 * Category: misc
 * Generated by Ghidra Bulk Exporter
 */

#include "../heavy_weapon_deluxe.h"


void __fastcall
CPU_Instruction31(undefined4 param_1,byte *param_2,undefined4 param_3,int param_4,byte *param_5,
                 byte *param_6,byte *param_7)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  byte bVar7;
  byte *pbVar8;
  int iVar9;
  byte *pbVar10;
  int local_c;
  int local_8;
  
  switch(param_7) {
  case (byte *)0x0:
    break;
  case (byte *)0x1:
    uVar3 = (int)(*(byte *)(param_4 + 0xb) + 7) >> 3;
    pbVar10 = param_5 + uVar3;
    if (uVar3 < *(uint *)(param_4 + 4)) {
      pbVar8 = pbVar10 + -uVar3;
      iVar4 = *(uint *)(param_4 + 4) - uVar3;
      do {
        *pbVar10 = *pbVar10 + *pbVar8;
        pbVar10 = pbVar10 + 1;
        pbVar8 = pbVar8 + 1;
        iVar4 = iVar4 + -1;
      } while (iVar4 != 0);
      return;
    }
    break;
  case (byte *)0x2:
    uVar3 = *(uint *)(param_4 + 4);
    uVar5 = 0;
    if (uVar3 != 0) {
      do {
        *param_5 = *param_5 + param_6[uVar5];
        param_5 = param_5 + 1;
        uVar5 = uVar5 + 1;
      } while (uVar5 < uVar3);
      return;
    }
    break;
  case (byte *)0x3:
    iVar4 = (int)(*(byte *)(param_4 + 0xb) + 7) >> 3;
    iVar6 = *(int *)(param_4 + 4) - iVar4;
    pbVar10 = param_5;
    for (; iVar4 != 0; iVar4 = iVar4 + -1) {
      *pbVar10 = *pbVar10 + (*param_6 >> 1);
      param_6 = param_6 + 1;
      pbVar10 = pbVar10 + 1;
    }
    if (iVar6 != 0) {
      do {
        bVar7 = *param_6;
        bVar1 = *param_5;
        param_5 = param_5 + 1;
        param_6 = param_6 + 1;
        *pbVar10 = *pbVar10 + (char)(((uint)bVar1 + (uint)bVar7) / 2);
        pbVar10 = pbVar10 + 1;
        iVar6 = iVar6 + -1;
      } while (iVar6 != 0);
      return;
    }
    break;
  case (byte *)0x4:
    iVar4 = (int)(*(byte *)(param_4 + 0xb) + 7) >> 3;
    local_c = *(int *)(param_4 + 4) - iVar4;
    pbVar10 = param_6;
    param_7 = param_5;
    for (; iVar4 != 0; iVar4 = iVar4 + -1) {
      *param_7 = *param_7 + *pbVar10;
      pbVar10 = pbVar10 + 1;
      param_7 = param_7 + 1;
    }
    if (local_c != 0) {
      do {
        bVar7 = *param_5;
        bVar1 = *pbVar10;
        param_5 = param_5 + 1;
        bVar2 = *param_6;
        pbVar10 = pbVar10 + 1;
        param_6 = param_6 + 1;
        iVar4 = (uint)bVar1 - (uint)bVar2;
        iVar6 = (uint)bVar7 - (uint)bVar2;
        local_8 = iVar4;
        if (iVar4 < 0) {
          local_8 = -iVar4;
        }
        iVar9 = iVar6;
        if (iVar6 < 0) {
          iVar9 = -iVar6;
        }
        iVar4 = iVar4 + iVar6;
        if (iVar4 < 0) {
          iVar4 = -iVar4;
        }
        if (((iVar9 < local_8) || (iVar4 < local_8)) && (bVar7 = bVar2, iVar9 <= iVar4)) {
          bVar7 = bVar1;
        }
        *param_7 = *param_7 + bVar7;
        param_7 = param_7 + 1;
        local_c = local_c + -1;
      } while (local_c != 0);
      return;
    }
    break;
  default:
    CPU_Instruction21(param_3,param_2,param_3,"Ignoring bad adaptive filter type");
    *param_5 = 0;
  }
  return;
}


