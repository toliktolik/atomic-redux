/*
 * Function: PixelFormat_ConvertRGBToYUV
 * Address: 004c0c80
 * Category: misc
 * Generated by Ghidra Bulk Exporter
 */

#include "../heavy_weapon_deluxe.h"


/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void __cdecl PixelFormat_ConvertRGBToYUV(uint *param_1)

{
  void *pvVar1;
  uint uVar2;
  byte bVar3;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint extraout_ECX_01;
  uint extraout_ECX_02;
  uint extraout_ECX_03;
  uint extraout_ECX_04;
  uint extraout_ECX_05;
  uint *extraout_EDX;
  uint *puVar4;
  uint *extraout_EDX_00;
  uint *extraout_EDX_01;
  uint *extraout_EDX_02;
  uint *puVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  ulonglong uVar11;
  ushort local_1c;
  uint *local_10;
  uint *local_8;
  
  puVar4 = param_1;
  if ((NAN((float)param_1[0x57]) || NAN((float)_DAT_0052a0c0)) ==
      ((float)param_1[0x57] == (float)_DAT_0052a0c0)) {
    if (*(byte *)((int)param_1 + 0x127) < 9) {
      pvVar1 = CPU_Instruction12((int)param_1,0x100);
      iVar8 = 0;
      param_1[0x59] = (uint)pvVar1;
      uVar2 = extraout_ECX;
      puVar4 = extraout_EDX;
      do {
        Math_ProcessFloatPrecision(uVar2,puVar4);
        uVar11 = Math_FloatToUInt64();
        puVar4 = (uint *)(uVar11 >> 0x20);
        uVar2 = param_1[0x59];
        *(char *)(iVar8 + uVar2) = (char)uVar11;
        iVar8 = iVar8 + 1;
      } while (iVar8 < 0x100);
      if ((param_1[0x1c] & 0x600080) != 0) {
        pvVar1 = CPU_Instruction12((int)param_1,0x100);
        iVar8 = 0;
        param_1[0x5b] = (uint)pvVar1;
        uVar2 = extraout_ECX_00;
        puVar4 = extraout_EDX_00;
        do {
          Math_ProcessFloatPrecision(uVar2,puVar4);
          uVar11 = Math_FloatToUInt64();
          puVar4 = (uint *)param_1[0x5b];
          *(char *)(iVar8 + (int)puVar4) = (char)uVar11;
          iVar8 = iVar8 + 1;
          uVar2 = extraout_ECX_01;
        } while (iVar8 < 0x100);
        pvVar1 = CPU_Instruction12((int)param_1,0x100);
        param_1[0x5a] = (uint)pvVar1;
        iVar8 = 0;
        uVar2 = extraout_ECX_02;
        puVar4 = extraout_EDX_01;
        do {
          Math_ProcessFloatPrecision(uVar2,puVar4);
          uVar11 = Math_FloatToUInt64();
          puVar4 = (uint *)(uVar11 >> 0x20);
          uVar2 = param_1[0x5a];
          *(char *)(iVar8 + uVar2) = (char)uVar11;
          iVar8 = iVar8 + 1;
        } while (iVar8 < 0x100);
        return;
      }
    }
    else {
      if ((*(byte *)((int)param_1 + 0x126) & 2) == 0) {
        uVar2 = (uint)*(byte *)((int)param_1 + 0x17f);
      }
      else {
        uVar2 = (uint)(byte)param_1[0x5f];
        if ((uint)(byte)param_1[0x5f] < (uint)*(byte *)((int)param_1 + 0x17d)) {
          uVar2 = (uint)*(byte *)((int)param_1 + 0x17d);
        }
        if (uVar2 < *(byte *)((int)param_1 + 0x17e)) {
          uVar2 = (uint)*(byte *)((int)param_1 + 0x17e);
        }
      }
      iVar8 = 0;
      if (uVar2 == 0) {
        param_1 = (uint *)0x0;
      }
      else {
        param_1 = (uint *)(0x10 - uVar2);
      }
      if (((puVar4[0x1c] & 0x400) == 0) || (4 < (int)param_1)) {
        if ((int)param_1 < 9) {
          if ((int)param_1 < 0) {
            param_1 = (uint *)0x0;
          }
        }
        else {
          param_1 = (uint *)0x8;
        }
      }
      else {
        param_1 = (uint *)0x5;
      }
      puVar4[0x56] = (uint)param_1 & 0xff;
      bVar3 = (byte)(8 - (int)param_1);
      iVar6 = 1 << (bVar3 & 0x1f);
      pvVar1 = CPU_Instruction12((int)puVar4,iVar6 * 4);
      puVar4[0x5c] = (uint)pvVar1;
      if ((puVar4[0x1c] & 0x480) == 0) {
        local_8 = (uint *)0x0;
        if (0 < iVar6) {
          do {
            pvVar1 = CPU_Instruction12((int)puVar4,0x200);
            uVar2 = puVar4[0x5c];
            *(void **)(uVar2 + (int)local_8 * 4) = pvVar1;
            iVar8 = 0;
            puVar5 = param_1;
            do {
              Math_ProcessFloatPrecision(uVar2,puVar5);
              uVar11 = Math_FloatToUInt64();
              uVar2 = *(uint *)(puVar4[0x5c] + (int)local_8 * 4);
              *(short *)(iVar8 + uVar2) = (short)uVar11;
              iVar8 = iVar8 + 2;
              puVar5 = local_8;
            } while (iVar8 < 0x200);
            local_8 = (uint *)((int)local_8 + 1);
          } while ((int)local_8 < iVar6);
        }
      }
      else {
        uVar2 = extraout_ECX_03;
        puVar5 = extraout_EDX_02;
        if (0 < iVar6) {
          do {
            pvVar1 = CPU_Instruction12((int)puVar4,0x200);
            puVar5 = (uint *)puVar4[0x5c];
            puVar5[iVar8] = (uint)pvVar1;
            iVar8 = iVar8 + 1;
            uVar2 = extraout_ECX_04;
          } while (iVar8 < iVar6);
        }
        uVar9 = 0;
        local_8 = (uint *)0x0;
        do {
          Math_ProcessFloatPrecision(uVar2,puVar5);
          uVar11 = Math_FloatToUInt64();
          puVar5 = (uint *)(uVar11 >> 0x20);
          uVar2 = extraout_ECX_05;
          if (uVar9 <= (uint)uVar11) {
            local_1c = (ushort)(((uint)local_8 & 0xff) << 8) | (ushort)local_8;
            do {
              puVar5 = (uint *)puVar4[0x5c];
              uVar2 = CONCAT22((short)((uint)(8 - (int)param_1) >> 0x10),local_1c);
              *(ushort *)
               (puVar5[0xff >> ((byte)param_1 & 0x1f) & uVar9] + (uVar9 >> (bVar3 & 0x1f)) * 2) =
                   local_1c;
              uVar9 = uVar9 + 1;
            } while (uVar9 <= (uint)uVar11);
          }
          local_8 = (uint *)((int)local_8 + 1);
        } while ((int)local_8 < 0x100);
        if (uVar9 < (uint)(iVar6 << 8)) {
          do {
            uVar2 = 0xff >> ((byte)param_1 & 0x1f) & uVar9;
            uVar7 = uVar9 >> (bVar3 & 0x1f);
            uVar9 = uVar9 + 1;
            *(undefined2 *)(*(int *)(puVar4[0x5c] + uVar2 * 4) + uVar7 * 2) = 0xffff;
          } while (uVar9 < (uint)(iVar6 << 8));
        }
      }
      if ((puVar4[0x1c] & 0x600080) != 0) {
        pvVar1 = CPU_Instruction12((int)puVar4,iVar6 << 2);
        puVar4[0x5e] = (uint)pvVar1;
        iVar8 = 0;
        if (0 < iVar6) {
          do {
            pvVar1 = CPU_Instruction12((int)puVar4,0x200);
            puVar5 = (uint *)puVar4[0x5e];
            puVar5[iVar8] = (uint)pvVar1;
            iVar10 = 0;
            local_10 = (uint *)((uint)(*(int *)((int)param_1 * 4 + 0x567ca8) * iVar8) >> 4);
            do {
              Math_ProcessFloatPrecision((uint)local_10,puVar5);
              uVar11 = Math_FloatToUInt64();
              *(short *)(iVar10 + *(int *)(puVar4[0x5e] + iVar8 * 4)) = (short)uVar11;
              puVar5 = local_10 + 0x40;
              iVar10 = iVar10 + 2;
              local_10 = puVar5;
            } while (iVar10 < 0x200);
            iVar8 = iVar8 + 1;
          } while (iVar8 < iVar6);
        }
        pvVar1 = CPU_Instruction12((int)puVar4,iVar6 << 2);
        puVar4[0x5d] = (uint)pvVar1;
        iVar8 = 0;
        if (0 < iVar6) {
          do {
            pvVar1 = CPU_Instruction12((int)puVar4,0x200);
            puVar5 = (uint *)puVar4[0x5d];
            puVar5[iVar8] = (uint)pvVar1;
            iVar10 = 0;
            local_10 = (uint *)((uint)(*(int *)((int)param_1 * 4 + 0x567ca8) * iVar8) >> 4);
            do {
              Math_ProcessFloatPrecision((uint)local_10,puVar5);
              uVar11 = Math_FloatToUInt64();
              *(short *)(iVar10 + *(int *)(puVar4[0x5d] + iVar8 * 4)) = (short)uVar11;
              puVar5 = local_10 + 0x40;
              iVar10 = iVar10 + 2;
              local_10 = puVar5;
            } while (iVar10 < 0x200);
            iVar8 = iVar8 + 1;
          } while (iVar8 < iVar6);
        }
      }
    }
  }
  return;
}


