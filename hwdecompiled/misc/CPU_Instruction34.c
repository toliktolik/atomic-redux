/*
 * Function: CPU_Instruction34
 * Address: 004c8c40
 * Category: misc
 * Generated by Ghidra Bulk Exporter
 */

#include "../heavy_weapon_deluxe.h"


void __fastcall CPU_Instruction34(uint param_1,byte *param_2,uint param_3,uint *param_4,int param_5)

{
  void *this;
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint extraout_ECX;
  uint extraout_ECX_00;
  undefined4 extraout_ECX_01;
  uint uVar4;
  byte *extraout_EDX;
  byte *extraout_EDX_00;
  byte *extraout_EDX_01;
  byte *pbVar5;
  byte *extraout_EDX_02;
  byte *extraout_EDX_03;
  byte *extraout_EDX_04;
  byte *extraout_EDX_05;
  byte *extraout_EDX_06;
  byte *extraout_EDX_07;
  byte *pbVar6;
  undefined4 *in_stack_ffffffdc;
  undefined4 *in_stack_ffffffe0;
  byte local_1c;
  byte local_1b;
  char local_1a;
  char local_19;
  byte local_18;
  
  this = DAT_00569f5c;
  if (*(int *)(param_3 + 0x68) != 0) {
    CPU_Instruction20(param_1,param_2,param_3,"Out of place IHDR");
    param_1 = extraout_ECX;
    param_2 = extraout_EDX;
  }
  if (param_5 != 0xd) {
    CPU_Instruction20(param_1,param_2,param_3,"Invalid IHDR chunk");
    param_1 = extraout_ECX_00;
    param_2 = extraout_EDX_00;
  }
  *(uint *)(param_3 + 0x68) = *(uint *)(param_3 + 0x68) | 1;
  CPU_Instruction26(param_1,param_2,param_3,&stack0xffffffdc,0xd);
  CPU_Instruction33(extraout_ECX_01,extraout_EDX_01,param_3,0);
  uVar2 = CPU_Instruction24(&stack0xffffffdc);
  uVar3 = CPU_Instruction24(&stack0xffffffe0);
  uVar4 = (uint)local_1b;
  pbVar5 = (byte *)(uint)local_18;
  if ((((uVar2 == 0) || (0x7fffffff < uVar2)) || (uVar3 == 0)) ||
     (pbVar6 = pbVar5, 0x7fffffff < uVar3)) {
    CPU_Instruction20(uVar4,pbVar5,param_3,"Invalid image size in IHDR");
    pbVar6 = extraout_EDX_02;
  }
  if (((local_1c != 1) && (local_1c != 2)) &&
     ((local_1c != 4 && ((local_1c != 8 && (local_1c != 0x10)))))) {
    CPU_Instruction20(uVar4,pbVar6,param_3,"Invalid bit depth in IHDR");
    pbVar6 = extraout_EDX_03;
  }
  if (((uVar4 == 1) || (uVar4 == 5)) || (6 < uVar4)) {
    CPU_Instruction20(uVar4,pbVar6,param_3,"Invalid color type in IHDR");
    pbVar6 = extraout_EDX_04;
  }
  if (uVar4 == 3) {
    if (local_1c < 9) goto LAB_004c8d79;
  }
  else if ((((uVar4 != 2) && (uVar4 != 4)) && (uVar4 != 6)) || (7 < local_1c)) goto LAB_004c8d79;
  CPU_Instruction20(uVar4,pbVar6,param_3,"Invalid color type/bit depth combination in IHDR");
  pbVar6 = extraout_EDX_05;
LAB_004c8d79:
  if ((byte *)0x1 < pbVar5) {
    CPU_Instruction20(uVar4,pbVar6,param_3,"Unknown interlace method in IHDR");
    pbVar6 = extraout_EDX_06;
  }
  if (local_1a != '\0') {
    CPU_Instruction20(uVar4,pbVar6,param_3,"Unknown compression method in IHDR");
    pbVar6 = extraout_EDX_07;
  }
  if (local_19 != '\0') {
    CPU_Instruction20(uVar4,pbVar6,param_3,"Unknown filter method in IHDR");
  }
  *(byte *)(param_3 + 0x123) = local_18;
  *(uint *)(param_3 + 200) = uVar2;
  *(uint *)(param_3 + 0xcc) = uVar3;
  *(byte *)(param_3 + 0x127) = local_1c;
  *(byte *)(param_3 + 0x126) = local_1b;
  switch(uVar4) {
  case 0:
  case 3:
    *(undefined1 *)(param_3 + 0x12a) = 1;
    break;
  case 2:
    *(undefined1 *)(param_3 + 0x12a) = 3;
    break;
  case 4:
    *(undefined1 *)(param_3 + 0x12a) = 2;
    break;
  case 6:
    *(undefined1 *)(param_3 + 0x12a) = 4;
  }
  bVar1 = *(char *)(param_3 + 0x12a) * local_1c;
  *(byte *)(param_3 + 0x129) = bVar1;
  *(uint *)(param_3 + 0xd8) = bVar1 * uVar2 + 7 >> 3;
  PNG_SetImageHeader(param_3,param_4,uVar2,uVar3,local_1c,local_1b,local_18,local_1a,local_19);
  Exception_SetMessage(this,in_stack_ffffffdc,in_stack_ffffffe0);
  return;
}


